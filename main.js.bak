// main.js - Main Electron Process

const { app, BrowserWindow, ipcMain, dialog, shell } = require('electron');
const path = require('path');
const { exec } = require('child_process');
const axios = require('axios');
const fs = require('fs');
const bz2 = require('unbzip2-stream');
const { pipeline } = require('stream/promises');
const Store = require('electron-store');

// Initialize persistent storage
const store = new Store();

let mainWindow; // Make mainWindow accessible

// Function to create the main application window
function createWindow() {
  mainWindow = new BrowserWindow({
    width: 1100,
    height: 900,
    autoHideMenuBar: true,
    webPreferences: {
      preload: path.join(__dirname, 'preload.js'),
      contextIsolation: true,
      nodeIntegration: false,
    },
  });

  mainWindow.loadFile('index.html');
  // mainWindow.webContents.openDevTools(); // Uncomment for debugging
}

// App lifecycle events
app.whenReady().then(() => {
  createWindow();

  app.on('activate', () => {
    if (BrowserWindow.getAllWindows().length === 0) {
      createWindow();
    }
  });
});

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

// Handle opening external links securely
ipcMain.on('open-external-link', (event, url) => {
    shell.openExternal(url);
});

// Helper to send status updates to the renderer process
const sendStatus = (status, message, data = {}) => {
    if (mainWindow) {
        mainWindow.webContents.send('download-status', { status, message, ...data });
    }
};

// IPC handler for electron-store
ipcMain.handle('electron-store', async (event, method, ...args) => {
    if (typeof store[method] === 'function') {
        return store[method](...args);
    }
    return store[method];
});

// IPC handler to open folder selection dialog
ipcMain.handle('dialog:openDirectory', async () => {
  const { canceled, filePaths } = await dialog.showOpenDialog(mainWindow, {
    properties: ['openDirectory'],
  });
  if (canceled) {
    return null;
  } else {
    store.set('downloadPath', filePaths[0]);
    return filePaths[0];
  }
});

// IPC handler for finding multiple demo URLs
ipcMain.handle('find-demos', async (event, codes) => {
    const results = { found: [], notFound: [] };
    for (const code of codes) {
        try {
            const url = await getDemoUrl(code);
            if (url) {
                results.found.push({ code, url });
            } else {
                results.notFound.push(code);
            }
        } catch (error) {
            results.notFound.push(code);
        }
    }
    return results;
});

// IPC handler for downloading all demos
ipcMain.on('download-all-demos', async (event, { urls, path: downloadPath, workers }) => {
    const tempDir = path.join(downloadPath, 'temp_demos');
    if (!fs.existsSync(tempDir)) fs.mkdirSync(tempDir);

    sendStatus('batch-start', `Starting batch download of ${urls.length} demos...`);
    
    const downloadQueue = [...urls];
    const decompressQueue = [];
    let isDecompressing = false;
    let completedCount = 0;

    const decompressWorker = async () => {
        if (isDecompressing || decompressQueue.length === 0) return;
        isDecompressing = true;
        
        const { tempFilePath, demFilename } = decompressQueue.shift();
        const finalDemPath = path.join(downloadPath, demFilename);

        try {
            sendStatus('decompressing', `Decompressing ${demFilename}...`);
            await decompressFile(tempFilePath, finalDemPath);
            fs.unlinkSync(tempFilePath); // Clean up temp file
            sendStatus('success', `Successfully saved ${demFilename}`);
        } catch (error) {
            sendStatus('error', `Failed to decompress ${demFilename}.`, { isError: true });
            if (fs.existsSync(tempFilePath)) fs.unlinkSync(tempFilePath);
        } finally {
            isDecompressing = false;
            completedCount++;
            if (completedCount === urls.length) {
                sendStatus('complete', 'All tasks finished!');
                if (fs.existsSync(tempDir)) fs.rmSync(tempDir, { recursive: true, force: true });
            } else {
                decompressWorker(); // Process next item
            }
        }
    };

    const downloadWorker = async () => {
        while (downloadQueue.length > 0) {
            const url = downloadQueue.shift();
            if (!url) continue;

            const bz2Filename = path.basename(new URL(url).pathname);
            const tempFilePath = path.join(tempDir, bz2Filename);
            
            try {
                await downloadFileWithTimeout(url, tempFilePath);
                sendStatus('downloaded', `${bz2Filename} downloaded, queued for decompression.`);
                decompressQueue.push({ tempFilePath, demFilename: bz2Filename.replace('.bz2', '') });
                if (!isDecompressing) decompressWorker();
            } catch (error) {
                sendStatus('error', `Failed to download ${bz2Filename}. Reason: ${error.message}`, { isError: true, retryUrl: url });
                completedCount++;
                 if (completedCount === urls.length) {
                    sendStatus('complete', 'All tasks finished!');
                }
            }
        }
    };

    const workerPromises = Array.from({ length: workers }, downloadWorker);
    await Promise.all(workerPromises);
});

// IPC handler for retrying a single download
ipcMain.on('retry-download', async (event, { url, path: downloadPath }) => {
    // This is a simplified version for a single retry.
    // In a full implementation, this would integrate with the main queues.
    sendStatus('info', `Retrying download for ${path.basename(new URL(url).pathname)}...`);
    // For simplicity, we'll just re-run the single download logic.
    await pipelineDownloadAndDecompress(url, downloadPath);
});


// IPC handler for the single download logic
ipcMain.on('download-demo', async (event, { shareCode, downloadPath }) => {
  try {
    sendStatus('fetching', 'Fetching demo URL...');
    const demoUrl = await getDemoUrl(shareCode);
    if (!demoUrl) throw new Error("Could not retrieve a valid demo URL.");
    
    sendStatus('fetching', `Successfully fetched demo URL.`);
    await pipelineDownloadAndDecompress(demoUrl, downloadPath);
    sendStatus('complete', 'Download and decompression complete!');
  } catch (error) {
    sendStatus('error', error.message, { isError: true });
  }
});

// --- Core Logic Functions ---

async function pipelineDownloadAndDecompress(demoUrl, downloadPath) {
    const demFilename = path.basename(new URL(demoUrl).pathname).replace('.bz2', '');
    const finalDemPath = path.join(downloadPath, demFilename);
    try {
        sendStatus('downloading', `Processing ${demFilename}...`);
        const response = await axios({ url: demoUrl, method: 'GET', responseType: 'stream' });
        await pipeline(response.data, bz2(), fs.createWriteStream(finalDemPath));
        sendStatus('success', `Successfully saved ${demFilename}`);
    } catch (error) {
        if (fs.existsSync(finalDemPath)) fs.unlinkSync(finalDemPath);
        throw error;
    }
}

async function downloadFileWithTimeout(url, destPath) {
    const writer = fs.createWriteStream(destPath);
    const response = await axios({
        url,
        method: 'GET',
        responseType: 'stream',
        timeout: 300000, // 5 minutes
    });
    response.data.pipe(writer);
    return new Promise((resolve, reject) => {
        writer.on('finish', resolve);
        writer.on('error', reject);
    });
}

function decompressFile(inputPath, outputPath) {
    return pipeline(fs.createReadStream(inputPath), bz2(), fs.createWriteStream(outputPath));
}

function getDemoUrl(shareCode) {
  return new Promise((resolve, reject) => {
    const isDev = !app.isPackaged;
    const resourcesPath = isDev ? __dirname : process.resourcesPath;
    const cliDirectory = path.join(resourcesPath, 'cs2-sharecode-cli');
    const scriptPath = path.join(cliDirectory, 'dist', 'index.js');
    const nodeExecutable = isDev ? 'node' : path.join(resourcesPath, 'bin', 'node.exe');
    const command = `"${nodeExecutable}" "${scriptPath}" demo-url "${shareCode}"`;

    exec(command, { cwd: cliDirectory }, (error, stdout, stderr) => {
      if (error) return reject(new Error(stderr || 'CLI execution failed'));
      const url = stdout.trim().split('\n').find(line => line.startsWith('http'));
      if (url) resolve(url);
      else reject(new Error('No valid URL found in CLI output.'));
    });
  });
}
